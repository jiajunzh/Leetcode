package problem;

/**
 * 1. Problem
 * You are given two positive 0-indexed integer arrays nums1 and nums2, both of length n.
 *
 * The sum of squared difference of arrays nums1 and nums2 is defined as the sum of (nums1[i] - nums2[i])2 for 
 * each 0 <= i < n.
 *
 * You are also given two positive integers k1 and k2. You can modify any of the elements of nums1 by +1 or -1 at most 
 * k1 times. Similarly, you can modify any of the elements of nums2 by +1 or -1 at most k2 times.
 *
 * Return the minimum sum of squared difference after modifying array nums1 at most k1 times and modifying array nums2 
 * at most k2 times.
 *
 * Note: You are allowed to modify the array elements to become negative integers.
 *
 * 2. Examples 
 * Example 1
 * Input: nums1 = [1,2,3,4], nums2 = [2,10,20,19], k1 = 0, k2 = 0
 * Output: 579
 * Explanation: The elements in nums1 and nums2 cannot be modified because k1 = 0 and k2 = 0. 
 * The sum of square difference will be: (1 - 2)2 + (2 - 10)2 + (3 - 20)2 + (4 - 19)2 = 579.
 * 
 * Example 2
 * Input: nums1 = [1,4,10,12], nums2 = [5,8,6,9], k1 = 1, k2 = 1
 * Output: 43
 * Explanation: One way to obtain the minimum sum of square difference is: 
 * - Increase nums1[0] once.
 * - Increase nums2[2] once.
 * The minimum of the sum of square difference will be: 
 * (2 - 5)2 + (4 - 8)2 + (10 - 7)2 + (12 - 9)2 = 43.
 * Note that, there are other ways to obtain the minimum of the sum of square difference, but there is no way to obtain a sum smaller than 43.
 *
 * 3. Constraints
 * n == nums1.length == nums2.length
 * 1 <= n <= 105
 * 0 <= nums1[i], nums2[i] <= 105
 * 0 <= k1, k2 <= 109
 */
public class MinimumSumOfSquaredDifference {

  /**
   * 1. Approach 
   * Array. 
   * 
   * This problem could be translated two perform at most k operations on diff array where 
   * => diff[i] = Math.abs(nums1[i] - nums2[i]) and k = k1 + k2
   * 
   * One challenge in this problem is k1,k2 >> n, so it is cheaper to iterate than k. Thus, this approach initialize an
   * array of size 100001 (maximum possible value of nums).
   * 
   * One trick used in this approach is that for the current examined number, if there are still remaining k operations,
   * then we decrease all current numbers i by 1 and then put the count of the current number i to current number - 1.
   * By that, it guarantees that when examining current number - 1, those generated by decreasing number i by 1 are also
   * considered.
   *
   * 2. Complexity 
   * - Time O(N) where N is the maximum possible value of difference between nums1 and nums2 OR length of nums,
   *             which are both 10^5
   * - Space O(N)
   * 
   * 3. Mistakes 
   * - The answer is long. Note integer overflow issue.
   * 
   * @param nums1
   * @param nums2
   * @param k1
   * @param k2
   * @return
   */
  public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {
    final int n = nums1.length;
    final int[] diff = new int[n];
    final int[] count = new int[100_001];
    int k = k1 + k2;
    int max = 0;
    for (int i = 0; i < n; i++) {
      diff[i] = Math.abs(nums1[i] - nums2[i]);
      count[diff[i]]++;
      max = Math.max(max, diff[i]);
    }
    long min = 0;
    for (int i = max; i > 0; i--) {
      if (count[i] == 0) continue;
      if (k > count[i]) {
        count[i - 1] += count[i];
        k -= count[i];
      } else {
        count[i - 1] += k;
        min = min + (long) Math.pow(i, 2) * (count[i] - k);
        k = 0;
      }
    }
    return min;
  }

  /**
   * 1. Approach 
   * Binary Search
   * 
   * 2. Complexity 
   * - Time O(NlogN)
   * - Space O(N)
   * 
   * @param nums1
   * @param nums2
   * @param k1
   * @param k2
   * @return
   */
  public long minSumSquareDiff2(int[] nums1, int[] nums2, int k1, int k2) {
    final int n = nums1.length;
    final long k = k1 + k2;
    final int[] diffs = new int[n];
    int min = 0, max = 0;
    for (int i = 0; i < n; i++) {
      diffs[i] = Math.abs(nums1[i] - nums2[i]);
      max = Math.max(max, diffs[i]);
    }

    // Find the minimum target such that countOfOperations(target) <= k1 + k2 if all numbers greater than target are decreased to target.
    while (min < max) {
      int mid = min + (max - min) / 2;
      if (countOperations(diffs, mid) > k) {
        min = mid + 1;
      } else {
        max = mid;
      }
    }
    if (min == 0) return 0;
    long remaining = k - countOperations(diffs, min);
    long answer = 0;
    for (int diff : diffs) {
      if (diff >= min) {
        if (remaining > 0) {
          answer += (long) (min - 1) * (min - 1);
          remaining--;
        } else {
          answer += (long) min * min;
        }
      } else {
        answer += (long) diff * diff;
      }
    }
    return answer;
  }

  private long countOperations(int[] diffs, int target) {
    long count = 0;
    for (int i = 0; i < diffs.length; i++) {
      count += Math.max(0, diffs[i] - target);
    }
    return count;
  }
}
